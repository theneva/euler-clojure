(for [x (range 10)])
(for [x (range 10)] prn)
(for [x (range 10)] println)
(range 10)
(range 10)00
(range 1000)
(range 10)
(map inc (range 10))
(map (prn) (range 10))
(map #(prn %) (range 10))
(map #(% + %) (range 10))
(map #(+ % %) (range 10))
(map % (range 10))
(defn by3 [x] (% x 3))
(defn by3 [x] (mod x 3))
(map by3 10))
(map by3 (range 10))
(defn by3 [x] (= 0 (mod x 3)))
(map by3 (range 10))
(defn by [x divisor] (mod x divisor))
(by 3 1)
(by 3 2)
(defn by [x divisor] (= 0 (mod x divisor)))
(by 3 2)
(by 3 1)
(filter #((or (by % 3) (by % 5) (by % 15))) (range 10))
(defn by3 [x] (by x 3))
defn by5 [x] (by x 5))
(defn by5 [x] (by x 5))
by3
by5
(defn by15 [x] (or by3 by5))
(by15 1
)
(by15 1)
(defn by15 [x] (or (by3 x) (by5 x)))
(by15 12)
(by15 100)
(by15 145)
(by15 45)
(defn by15 [x] (by x 15))
(by15 15)
(by15 14)
(defn valid [x] (or (by3 x) (by5 x) (by15) x))
(valid 2)
(defn valid [x] (or (by3 x) (by5 x) (by15 x)))
(valid 2)
(valid 15)
(valid 13)
(valid 3)
(filter valid (range 10))
(filter valid (range 1 10))
(filter valid (range 1 1000))
(reduce + (filter valid (range 1 1000)))
(range 1 10)
(reduce +
(defn divisible [x y] (= 0 (mod x y)))
(reduce + (filter #(or (divisible % 3) (divisible % 5)) (range 1 1000)))
(def list (range 1 10))
(def numbers (range 1 10))
numbers
(defn divisible? [x y] (= 0 (mod x y)))
(filter #((divisible? % 3)) numbers)
(filter #(divisible? % 3) numbers)
(filter #(or (divisible? % 3) (divisible? % 5)) numbers)
(reduce + (filter #(or (divisible? % 3) (divisible? % 5)) numbers))
(reduce + (filter #(or (divisible? % 3) (divisible? % 5)) (range 1 1000)))
(filter #(or (divisible? % 3) (divisible? % 5)) numbers)
(-> (range 1 10)
 #(divisible? % 3))
 #(divisible? % 3)
(-> (range 1 10))
(->> (range 1 10)) filter)
(->> (range 1 10)) filter true)
(->> (range 1 10) filter true)
(->> (range 1 10) filter (true)))
(->> (range 1 10) filter (true))
(->> (range 1 10) filter (true?))
(->> (range 1 10) filter (false?))
(->> (range 1 10) (filter (= % %)))
(->> (range 1 10) #(filter (= % %)))
(->> (range 1 10) #(filter (= % %)) println)
(->> (range 1 10) #(filter (= % %)) prn)
(->> (range 1 10) #(filter (= 1 2)) )
(->> (range 1 10) #(filter (= 1 2)))
(->> (range 1 10) #(filter (= 1 2)) prn)
(->> (range 1 10) #(filter (= 1 2)))
(->> (range 1 10) (filter (= 1 2)) (reduce +))
(->> (range 1 10) (filter #(= 1 2)) (reduce +))
(->> (range 1 10) prn)
(->> (range 1 10) prn 1)
(defn prn2 [x y] (concat x y))
(defn prn2 [x y] (-> (concat x y) prn))
(prn2 123 354)
(defn prn2 [x y] (-> (seq x y) prn))
(prn2 123 354)
(defn prn2 [x y] (-> (list x y) prn))
(prn2 123 354)
(defn prn2 [x y] (-> (list x y) prn))
(list 1 2 3)
(defn prn2 [x y] (->> x prn))
(prn2 1 2)
(prn2 1 4)
(defn prn2 [x y] (->> x prn y))
(prn2 1 4)
(defn prn2 [x y] (->> x list (prn y)))
(defn prn2 [x y] (->> x (list y) prn))
(prn2 1 4)
(defn div? [x y] (= 0 (mod x y)))
(->> (range 1 10)
 prn)
(->> (range 1 10)
 (filter #(or (div? % 3) (div? % 5)))
 (reduce +))
(->> (range 1 10)
 (filter #(or (div? % 3) (div? % 5)))
 (reduce +))
(defn <4MM [x] (< x 4000000))
(<4MM 1000)
(<4MM 100000000000)
(take-while <4MM range)
(take-while <4MM (range))
(take-while <4MM (range 1 10))
(->> (range 1 10)
 prn)
(->> (range 1 10)
(-> (range 1 10) (take-while (< 5)))
(-> (range 1 10) (take-while #(< 5)))
(-> (range 1 10) (take-while #(5 %)))
(->> (range 1 10) (take-while #(5 %))
)
(->> (range 1 10) (take-while #(5 %)))
(->> (range 1 10) (take-while #(% 5)))
(->> (range 1 10) (take-while true?))
(->> (range 1 10) (take-while #(< 5 %))
(->> (range 1 10) (take-while #(< 5 %)))
(take-while neg? (range -5 5)
)
(take-while neg? (range -5 5))
(take-while #(< 5 %) (range -5 5))
(take-while #(< 5) (range -5 5))
(take-while #(< % 5) (range -5 5))
(take-while #(< % 2) (range -5 5))
(take-while #(< % 4000000) (range -5 5))
(->> (range 1 10) (take-while #(< % 7)))
(->> (range 1 10)(take-while #(< % 7)))
(->> (range 1 10) (take-while #(< % 7)))
(->> fibs (take-while #(< % 7)))
(->> (fib) (take-while #(< % 7)))
(defn fib [n] (+ (fib (- n 2)) (fib (- n 1))))
(->> (fib 1000000000) (take-while #(< % 7)))
(->> (fib 10000000) (take-while #(< % 7)))
(->> (fib 10000) (take-while #(< % 7)))
(->> (fib) (take-while #(< % 7)))
(defn fib ([] (fib 1000000)) ([n] (+ (fib (- n 2)) (fib (- n 1)))))
fib
(fib)
(- 5 2)
(defn fib ([] (fib 1000000)) ([n] (+ (fib (- n 2)) (fib (- n 1)))))
(range 1 10)
(->> (range 1 10) fib)
(defn fib [n] (if (= 2 n) n (+ (fib (- n 2) (fib (- n 1))))))
(fib 1)
(fib 2)
(fib 3)
(fib 4)
(load 02.clj)
(load "02.clj")
(load-file "02.clj")
(fib 3)
(fib 2)
(fib 5)
(load-file "02.clj")
(fib 5)
(fib 2)
(fib 3)
(fib 4)
(fib 6)
(load-file "02.clj")
(fib 6)
(fib 1)
(fib 2)
(fib 3)
(fib 4)
(fib 5)
(->> (range 1 10) fib)
(->> (range 1 10) (map fib))
(->> (range 1 11) (map fib))
(load-file "02.clj")
(take-while #(< % 5) (range 1 10))
(take-while #(< % 5) (range 1 3))
(load-file "02.clj")
(time (load-file "02.clj"))
(load-file "02.clj")
(time (load-file "02.clj"))
(load-file "02.clj")
(load-file "03.clj")
(load-file "02.clj")
(time !!)
(time (load-file "02.clj"))
(time (load-file "03.clj"))
(prime? 3)
(prime? 5)
(prime? 4)
(prime? 5)
(time (load-file "03.clj"))
(prime? 5)
(prime? 6)
(prime? 7)
(time (load-file "03.clj"))
(smallest-prime-factor 10)
(smallest-prime-factor 5)
(prime? 5)
(prime? 3)
(prime? 2)
(time (load-file "03.clj"))
(prime? 2)
(prime? 3)
(prime? 4)
(time (load-file "03.clj"))
(prime? 3)
(prime? 4)
(time (load-file "03.clj"))
(prime? 4)
(prime? 2)
(prime? 3
(prime? 3)
(prime? 5)
(time (load-file "03.clj"))
(prime? 5)
(prime? 2)
(prime? 3)
(prime? 4)
(prime? 27)
(prime? 23)
(smallest-prime-factor 10)
(time (load-file "03.clj"))
(smallest-prime-factor 10)
(time (load-file "03.clj"))
(smallest-prime-factor 10)
(time (load-file "03.clj"))
(smallest-prime-factor 10)
(smallest-prime-factor 20)
(smallest-prime-factor 21)
(smallest-prime-factor 7)
(smallest-prime-factor 1)
(smallest-prime-factor 12
(smallest-prime-factor 3
)
(smallest-prime-factor 4)
(smallest-prime-factor 6)
(smallest-prime-factor 8)
(smallest-prime-factor 9)
(smallest-prime-factor 8)
rload
(time (load-file "03.clj"))
(smallest-prime-factor 8)
(smallest-prime-factor 9)
(smallest-prime-factor 2)
(smallest-prime-factor 1)
(smallest-prime-factor 10000)
(smallest-prime-factor 10001)
(time (load-file "03.clj"))
(largest-prime-factor 13195)
(largest-prime-factor 13195 1)
(largest-prime-factor 600851475143 1)
(time (largest-prime-factor 600851475143 1))
(time (largest-prime-factor 600851475143))
(time (load-file "03.clj"))
(time (largest-prime-factor 600851475143))
(time (largest-prime-factor 600851475143 3))
(time (largest-prime-factor 600851475143 1))
(time (largest-prime-factor 600851475143))
(time (load-file "03.clj"))
(time (load-file "04.clj"))
(palindromic? 13)
(palindromic? 1331)
(time (load-file "04.clj"))
(str 123)
(str 1221)
(reverse (str 1221))
(clojure.string/reverse (str 1221))
(string/reverse (str 1221))
(time (load-file "04.clj"))
(reverse (str(1221))
(reverse (str(1221)))
(reverse (str(1221))
(reverse (str(1221)))
(reverse (str1221))
(reverse (str 1221))
(clojure.string/reverse (str 1221))
(time (load-file "04.clj"))
(time (load-file "05.clj"))
(def n 10)
(for [x (range)
             y (range 1 (inc n))]
         (divisible? x y))
(defn divisible? [x, y] (= 0 (mod x y)))
(divisible 10 2)
(divisible? 10 2)
(divisible? 10 3)
n
(for [x (range)
  0              y (range 1 (inc n))]
  1          (divisible? x y))
(for [x (range)
             y (range 1 (inc n))]
         (divisible? x y))
(take 5 (for [x (range)
             y (range 1 (inc n))]
         (divisible? x y)))
(time (load-file "05.clj"))
(time (load-file "04.clj"))
(time (load-file "05.clj"))
(time (load-file "04.clj"))
(time (load-file "05.clj"))
(time (load-file "03.clj"))
(largest-prime-factor 670442572800)
(largest-prime-factor (/ 670442572800 2)
(largest-prime-factor (/ 670442572800 2))
(time (load-file "05.clj"))
